# Go 动态线程池 (Dynamic Worker Pool)

一个高性能的 Go 语言线程池实现，采用双层队列架构，支持动态扩缩容、智能任务分发和实时监控。

## 特性

### 核心功能
- ✅ **双层队列架构**: 全局任务队列 + 本地任务队列
- ✅ **核心线程数管理**: 维护固定数量的核心工作线程
- ✅ **最大线程数限制**: 防止线程数量无限增长
- ✅ **优雅关闭**: 支持超时等待的优雅关闭机制

### 动态扩缩容
- 🚀 **自动扩容**: 队列满时自动增加非核心工作线程
- 📉 **自动缩容**: 空闲时自动回收非核心工作线程
- ⚡ **智能策略**: 基于队列状态的动态调整策略
- 🎯 **任务分发**: 随机分发到本地队列，提升性能

### 任务管理
- 📋 **任务接口**: 灵活的任务定义接口
- ⏱️ **超时任务**: 支持带超时的任务执行
- 📊 **详细统计**: 实时获取线程池运行状态和任务完成率

## 项目结构
```diff
worker_pool/
├── pool.go          # 线程池核心实现
├── worker.go        # 工作线程实现
├── task.go          # 任务定义和实现
├── config.go        # 配置管理
├── stats.go         # 统计信息
├── example/
│   └── main.go      # 使用示例
├── go.mod           # Go 模块文件
└── README.md        # 项目文档
```


## 快速开始

### 基本使用

```go
package main

import (
    "fmt"
    "time"
    "worker_pool"
)

func main() {

    // 创建并启动线程池
    pool := worker_pool.NewWorkerPool()
    pool.Start()

    // 提交任务
    task := worker_pool.NewFuncTask(func() {
        fmt.Println("Hello from worker pool!")
    })
    pool.Submit(task)

    // 关闭线程池
    pool.Shutdown(10 * time.Second)
}
```

### 线程池配置参数

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `CoreWorkers` | int | 5 | 核心工作线程数，始终保持活跃 |
| `MaxWorkers` | int | 20 | 最大工作线程数，包含核心和非核心线程 |
| `QueueSize` | int | 100 | 全局任务队列缓冲区大小 |
| `LocalQueueSize` | int | 10 | 本地任务队列缓冲区大小 |
| `MonitorInterval` | time.Duration | 5s | 工作者空闲检查间隔 |

## 双层队列架构

### 任务分发机制
1. **随机分发**: 任务首先随机分发到工作者的本地队列
2. **全局队列**: 本地队列满时，任务进入全局队列
3. **直接执行**: 全局队列满时，扩容后重新分发任务。double chance

### 动态扩缩容机制

#### 扩容策略
线程池在以下情况下会自动扩容：
- 当前工作线程数 < 最大线程数
- 全局队列已满且有新任务提交

#### 缩容策略
线程池在以下情况下会自动缩容：
- 存在非核心工作线程
- 本地队列为空
- 全局队列负载低于阈值
- 空闲时间超过 20 秒

## API 文档

### WorkerPool

#### 方法

- `NewWorkerPool() *WorkerPool`: 创建新的线程池
- `Start() error`: 启动线程池
- `Submit(task Task) error`: 提交任务到线程池
- `GetStats() Stats`: 获取线程池统计信息
- `Shutdown(timeout time.Duration) error`: 关闭线程池

### Task 接口

```go
type Task interface {
    Execute()
}
```

#### 内置任务类型

- `FuncTask`: 函数任务，包装普通函数
- `TimedTask`: 带超时的任务包装器

### Stats 统计信息

```go
type Stats struct {
    CoreWorkers      int  // 核心工作线程数
    NonCoreWorkers   int  // 非核心工作线程数
    TotalWorkers     int  // 总工作线程数
    QueueLength      int  // 全局队列长度
    LocalQueueLength int  // 本地队列总长度
    ActiveJobs       int  // 活跃任务数
    TotalTasks       int  // 总任务数
    CompletedTasks   int  // 已完成任务数
    IsRunning        bool // 是否运行中
}
```

### 任务完成率
统计信息包含任务完成率计算，帮助监控线程池性能：
- 完成率 = 已完成任务数 / 总任务数 × 100%
- 实时显示处理效率和性能指标

## 使用示例

查看 `example/main.go` 文件，其中包含了完整的使用示例，演示了：

1. **正常负载**: 提交少量任务，观察核心线程处理
2. **高并发负载**: 同时提交大量任务，触发自动扩容
3. **负载降低**: 任务完成后，观察自动缩容过程
4. **实时监控**: 持续输出线程池统计信息

运行示例：

```bash
cd example
go run main.go
```

示例输出包含：
- 任务执行状态
- 线程池扩缩容过程
- 实时统计信息
- 任务完成率

## 性能特点

### 优势
- **高性能**: 双层队列架构减少锁竞争，提升并发性能
- **内存效率**: 动态调整线程数，避免资源浪费
- **响应迅速**: 高负载时快速扩容，提升处理能力
- **智能分发**: 随机分发任务到本地队列，避免热点问题
- **自动管理**: 无需手动干预，自动适应负载变化
- **线程安全**: 使用原子操作和读写锁保证并发安全

### 适用场景
- Web 服务器请求处理
- 批量数据处理
- 异步任务执行
- 需要动态调整并发度的场景
- 高并发任务处理系统
- 微服务架构中的任务调度

## 注意事项

1. **任务设计**: 确保任务不会长时间阻塞，避免影响线程池效率
2. **配置调优**: 根据实际业务场景调整核心线程数和最大线程数
3. **队列大小**: 合理配置本地队列和全局队列大小，平衡内存使用和性能
4. **空闲检查**: 空闲检查间隔不宜过短，避免频繁调整造成抖动
5. **任务丢失**: 队列满时可能导致任务丢失，需要做好错误处理

## 许可证

MIT License